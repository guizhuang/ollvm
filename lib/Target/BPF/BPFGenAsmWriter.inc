/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Assembly Writer Source Fragment                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void BPFInstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
  static const char AsmStrs[] = {
  /* 0 */ 'x', 'a', 'd', 'd', '3', '2', 9, 0,
  /* 8 */ 'b', 's', 'w', 'a', 'p', '3', '2', 9, 0,
  /* 17 */ 'l', 'd', '_', '6', '4', 9, 0,
  /* 24 */ 'x', 'a', 'd', 'd', '6', '4', 9, 0,
  /* 32 */ 'b', 's', 'w', 'a', 'p', '6', '4', 9, 0,
  /* 41 */ 'b', 's', 'w', 'a', 'p', '1', '6', 9, 0,
  /* 50 */ 'l', 'e', 'a', 9, 0,
  /* 55 */ 's', 'r', 'a', 9, 0,
  /* 60 */ 'l', 'd', 'b', 9, 0,
  /* 65 */ 's', 't', 'b', 9, 0,
  /* 70 */ 's', 'u', 'b', 9, 0,
  /* 75 */ 'a', 'd', 'd', 9, 0,
  /* 80 */ 'l', 'd', 'd', 9, 0,
  /* 85 */ 'a', 'n', 'd', 9, 0,
  /* 90 */ 's', 't', 'd', 9, 0,
  /* 95 */ 'j', 'g', 'e', 9, 0,
  /* 100 */ 'j', 's', 'g', 'e', 9, 0,
  /* 106 */ 'j', 'n', 'e', 9, 0,
  /* 111 */ 'l', 'd', 'h', 9, 0,
  /* 116 */ 's', 't', 'h', 9, 0,
  /* 121 */ 's', 'r', 'a', 'i', 9, 0,
  /* 127 */ 's', 'u', 'b', 'i', 9, 0,
  /* 133 */ 'a', 'd', 'd', 'i', 9, 0,
  /* 139 */ 'a', 'n', 'd', 'i', 9, 0,
  /* 145 */ 'j', 'g', 'e', 'i', 9, 0,
  /* 151 */ 'j', 's', 'g', 'e', 'i', 9, 0,
  /* 158 */ 'j', 'n', 'e', 'i', 9, 0,
  /* 164 */ 's', 'l', 'l', 'i', 9, 0,
  /* 170 */ 's', 'r', 'l', 'i', 9, 0,
  /* 176 */ 'm', 'u', 'l', 'i', 9, 0,
  /* 182 */ 'j', 'e', 'q', 'i', 9, 0,
  /* 188 */ 'x', 'o', 'r', 'i', 9, 0,
  /* 194 */ 'j', 'g', 't', 'i', 9, 0,
  /* 200 */ 'j', 's', 'g', 't', 'i', 9, 0,
  /* 207 */ 'd', 'i', 'v', 'i', 9, 0,
  /* 213 */ 'c', 'a', 'l', 'l', 9, 0,
  /* 219 */ 's', 'l', 'l', 9, 0,
  /* 224 */ 's', 'r', 'l', 9, 0,
  /* 229 */ 'm', 'u', 'l', 9, 0,
  /* 234 */ 'l', 'd', '_', 'p', 's', 'e', 'u', 'd', 'o', 9, 0,
  /* 245 */ 'j', 'm', 'p', 9, 0,
  /* 250 */ 'n', 'o', 'p', 9, 0,
  /* 255 */ 'j', 'e', 'q', 9, 0,
  /* 260 */ 'x', 'o', 'r', 9, 0,
  /* 265 */ 'j', 'g', 't', 9, 0,
  /* 270 */ 'j', 's', 'g', 't', 9, 0,
  /* 276 */ 'd', 'i', 'v', 9, 0,
  /* 281 */ 'm', 'o', 'v', 9, 0,
  /* 286 */ 'l', 'd', 'w', 9, 0,
  /* 291 */ 's', 't', 'w', 9, 0,
  /* 296 */ 'l', 'd', 'i', 'n', 'd', '_', 'b', 9, 'r', '0', ',', 32, 0,
  /* 309 */ 'l', 'd', 'a', 'b', 's', '_', 'b', 9, 'r', '0', ',', 32, 0,
  /* 322 */ 'l', 'd', 'i', 'n', 'd', '_', 'h', 9, 'r', '0', ',', 32, 0,
  /* 335 */ 'l', 'd', 'a', 'b', 's', '_', 'h', 9, 'r', '0', ',', 32, 0,
  /* 348 */ 'l', 'd', 'i', 'n', 'd', '_', 'w', 9, 'r', '0', ',', 32, 0,
  /* 361 */ 'l', 'd', 'a', 'b', 's', '_', 'w', 9, 'r', '0', ',', 32, 0,
  /* 374 */ '#', 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'D', 'O', 'W', 'N', 32, 0,
  /* 393 */ '#', 32, 'S', 'e', 'l', 'e', 'c', 't', 32, 'P', 'S', 'E', 'U', 'D', 'O', 32, 0,
  /* 410 */ '#', 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'U', 'P', 32, 0,
  /* 427 */ '#', 32, 'X', 'R', 'a', 'y', 32, 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n', 32, 'E', 'n', 't', 'e', 'r', '.', 0,
  /* 450 */ '#', 32, 'X', 'R', 'a', 'y', 32, 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n', 32, 'E', 'x', 'i', 't', '.', 0,
  /* 472 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'E', 'N', 'D', 0,
  /* 485 */ 'B', 'U', 'N', 'D', 'L', 'E', 0,
  /* 492 */ 'D', 'B', 'G', '_', 'V', 'A', 'L', 'U', 'E', 0,
  /* 502 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'S', 'T', 'A', 'R', 'T', 0,
  /* 517 */ 'r', 'e', 't', 0,
  };

  static const uint16_t OpInfo0[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    493U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    486U,	// BUNDLE
    503U,	// LIFETIME_START
    473U,	// LIFETIME_END
    0U,	// STACKMAP
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_LOAD_OP
    0U,	// PATCHABLE_OP
    428U,	// PATCHABLE_FUNCTION_ENTER
    451U,	// PATCHABLE_RET
    0U,	// G_ADD
    0U,	// G_OR
    0U,	// G_BR
    1158U,	// ADD_ri
    1100U,	// ADD_rr
    5495U,	// ADJCALLSTACKDOWN
    9627U,	// ADJCALLSTACKUP
    1164U,	// AND_ri
    1110U,	// AND_rr
    5162U,	// BSWAP16
    5129U,	// BSWAP32
    5153U,	// BSWAP64
    1232U,	// DIV_ri
    1301U,	// DIV_rr
    33843U,	// FI_ri
    5334U,	// JAL
    1207U,	// JEQ_ri
    1280U,	// JEQ_rr
    5366U,	// JMP
    1183U,	// JNE_ri
    1131U,	// JNE_rr
    1176U,	// JSGE_ri
    1125U,	// JSGE_rr
    1225U,	// JSGT_ri
    1295U,	// JSGT_rr
    1170U,	// JUGE_ri
    1120U,	// JUGE_rr
    1219U,	// JUGT_ri
    1290U,	// JUGT_rr
    33853U,	// LDB
    33873U,	// LDD
    33904U,	// LDH
    34079U,	// LDW
    13622U,	// LD_ABS_B
    13648U,	// LD_ABS_H
    13674U,	// LD_ABS_W
    13609U,	// LD_IND_B
    13635U,	// LD_IND_H
    13661U,	// LD_IND_W
    33810U,	// LD_imm64
    1259U,	// LD_pseudo
    1306U,	// MOV_ri
    1306U,	// MOV_rr
    1201U,	// MUL_ri
    1254U,	// MUL_rr
    5371U,	// NOP
    1214U,	// OR_ri
    1286U,	// OR_rr
    518U,	// RET
    1189U,	// SLL_ri
    1244U,	// SLL_rr
    1146U,	// SRA_ri
    1080U,	// SRA_rr
    1195U,	// SRL_ri
    1249U,	// SRL_rr
    2114U,	// STB
    2139U,	// STD
    2165U,	// STH
    2340U,	// STW
    1152U,	// SUB_ri
    1095U,	// SUB_rr
    17802U,	// Select
    33793U,	// XADD32
    33817U,	// XADD64
    1213U,	// XOR_ri
    1285U,	// XOR_rr
  };

  static const uint8_t OpInfo1[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    0U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    0U,	// BUNDLE
    0U,	// LIFETIME_START
    0U,	// LIFETIME_END
    0U,	// STACKMAP
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_LOAD_OP
    0U,	// PATCHABLE_OP
    0U,	// PATCHABLE_FUNCTION_ENTER
    0U,	// PATCHABLE_RET
    0U,	// G_ADD
    0U,	// G_OR
    0U,	// G_BR
    0U,	// ADD_ri
    0U,	// ADD_rr
    0U,	// ADJCALLSTACKDOWN
    0U,	// ADJCALLSTACKUP
    0U,	// AND_ri
    0U,	// AND_rr
    0U,	// BSWAP16
    0U,	// BSWAP32
    0U,	// BSWAP64
    0U,	// DIV_ri
    0U,	// DIV_rr
    0U,	// FI_ri
    0U,	// JAL
    3U,	// JEQ_ri
    3U,	// JEQ_rr
    0U,	// JMP
    3U,	// JNE_ri
    3U,	// JNE_rr
    3U,	// JSGE_ri
    3U,	// JSGE_rr
    3U,	// JSGT_ri
    3U,	// JSGT_rr
    3U,	// JUGE_ri
    3U,	// JUGE_rr
    3U,	// JUGT_ri
    3U,	// JUGT_rr
    0U,	// LDB
    0U,	// LDD
    0U,	// LDH
    0U,	// LDW
    0U,	// LD_ABS_B
    0U,	// LD_ABS_H
    0U,	// LD_ABS_W
    0U,	// LD_IND_B
    0U,	// LD_IND_H
    0U,	// LD_IND_W
    1U,	// LD_imm64
    5U,	// LD_pseudo
    1U,	// MOV_ri
    1U,	// MOV_rr
    0U,	// MUL_ri
    0U,	// MUL_rr
    0U,	// NOP
    0U,	// OR_ri
    0U,	// OR_rr
    0U,	// RET
    0U,	// SLL_ri
    0U,	// SLL_rr
    0U,	// SRA_ri
    0U,	// SRA_rr
    0U,	// SRL_ri
    0U,	// SRL_rr
    0U,	// STB
    0U,	// STD
    0U,	// STH
    0U,	// STW
    0U,	// SUB_ri
    0U,	// SUB_rr
    0U,	// Select
    12U,	// XADD32
    12U,	// XADD64
    0U,	// XOR_ri
    0U,	// XOR_rr
  };

  O << "\t";

  // Emit the opcode for the instruction.
  uint32_t Bits = 0;
  Bits |= OpInfo0[MI->getOpcode()] << 0;
  Bits |= OpInfo1[MI->getOpcode()] << 16;
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023)-1;


  // Fragment 0 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 10) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // DBG_VALUE, BUNDLE, LIFETIME_START, LIFETIME_END, PATCHABLE_FUNCTION_EN...
    return;
    break;
  case 1:
    // ADD_ri, ADD_rr, ADJCALLSTACKDOWN, ADJCALLSTACKUP, AND_ri, AND_rr, BSWA...
    printOperand(MI, 0, O);
    break;
  case 2:
    // STB, STD, STH, STW
    printMemOperand(MI, 1, O);
    O << ", ";
    printOperand(MI, 0, O);
    return;
    break;
  }


  // Fragment 1 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 12) & 7) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADD_ri, ADD_rr, AND_ri, AND_rr, DIV_ri, DIV_rr, FI_ri, JEQ_ri, JEQ_rr,...
    O << ", ";
    break;
  case 1:
    // ADJCALLSTACKDOWN, BSWAP16, BSWAP32, BSWAP64, JAL, JMP, NOP
    return;
    break;
  case 2:
    // ADJCALLSTACKUP
    O << ' ';
    printOperand(MI, 1, O);
    return;
    break;
  case 3:
    // LD_ABS_B, LD_ABS_H, LD_ABS_W, LD_IND_B, LD_IND_H, LD_IND_W
    O << ".data + ";
    printOperand(MI, 1, O);
    return;
    break;
  case 4:
    // Select
    O << " = ";
    printOperand(MI, 1, O);
    O << ' ';
    printOperand(MI, 3, O);
    O << ' ';
    printOperand(MI, 2, O);
    O << " ? ";
    printOperand(MI, 4, O);
    O << " : ";
    printOperand(MI, 5, O);
    return;
    break;
  }


  // Fragment 2 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 15) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADD_ri, ADD_rr, AND_ri, AND_rr, DIV_ri, DIV_rr, MUL_ri, MUL_rr, OR_ri,...
    printOperand(MI, 2, O);
    return;
    break;
  case 1:
    // FI_ri, LDB, LDD, LDH, LDW, XADD32, XADD64
    printMemOperand(MI, 1, O);
    break;
  case 2:
    // JEQ_ri, JEQ_rr, JNE_ri, JNE_rr, JSGE_ri, JSGE_rr, JSGT_ri, JSGT_rr, JU...
    printOperand(MI, 1, O);
    break;
  case 3:
    // LD_imm64
    printImm64Operand(MI, 1, O);
    return;
    break;
  }


  // Fragment 3 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 17) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // FI_ri, LDB, LDD, LDH, LDW, MOV_ri, MOV_rr
    return;
    break;
  case 1:
    // JEQ_ri, JEQ_rr, JNE_ri, JNE_rr, JSGE_ri, JSGE_rr, JSGT_ri, JSGT_rr, JU...
    O << " goto ";
    printOperand(MI, 2, O);
    return;
    break;
  case 2:
    // LD_pseudo, XADD32, XADD64
    O << ", ";
    break;
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 19) & 1) {
    // XADD32, XADD64
    printOperand(MI, 3, O);
    return;
  } else {
    // LD_pseudo
    printImm64Operand(MI, 2, O);
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *BPFInstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 13 && "Invalid register number!");

  static const char AsmStrs[] = {
  /* 0 */ 'r', '1', '0', 0,
  /* 4 */ 'r', '0', 0,
  /* 7 */ 'r', '1', '1', 0,
  /* 11 */ 'r', '1', 0,
  /* 14 */ 'r', '2', 0,
  /* 17 */ 'r', '3', 0,
  /* 20 */ 'r', '4', 0,
  /* 23 */ 'r', '5', 0,
  /* 26 */ 'r', '6', 0,
  /* 29 */ 'r', '7', 0,
  /* 32 */ 'r', '8', 0,
  /* 35 */ 'r', '9', 0,
  };

  static const uint8_t RegAsmOffset[] = {
    4, 11, 14, 17, 20, 23, 26, 29, 32, 35, 0, 7, 
  };

  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

bool BPFInstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
  return false;
}

#endif // PRINT_ALIAS_INSTR
